Sun Mar 11 20:12:25 2018 +0300 0ed33ad0 (HEAD -> developing) a  [Suleyman Poyraz]
diff --git a/inary/analyzer/ctypes.py b/inary/analyzer/ctypes_analyzer.py
similarity index 100%
rename from inary/analyzer/ctypes.py
rename to inary/analyzer/ctypes_analyzer.py
diff --git a/inary/analyzer/firmwares.py b/inary/analyzer/firmwares.py
index 597c7628..a93bfef6 100644
--- a/inary/analyzer/firmwares.py
+++ b/inary/analyzer/firmwares.py
@@ -21,11 +21,6 @@ import gettext
 __trans = gettext.translation('inary', fallback=True)
 _ = __trans.gettext
 
-
-FW_PATH = "/lib/firmware"
-INSTALDB = inary.db.installdb.InstallDB()
-COMPONENTDB = inary.db.componentdb.ComponentDB()
-
 class Error(inary.Error):
     pass
 
@@ -46,8 +41,8 @@ def get_firmwares():
 
 def get_firmware_package(firmware):
     try:
-        fw_packages = COMPONENTDB.get_packages("hardware.firmware")
-        unavailable_fw_packages = set(fw_packages).difference(INSTALLDB.list_installed())
+        fw_packages = inary.db.componentdb.ComponentDB().get_packages("hardware.firmware")
+        unavailable_fw_packages = set(fw_packages).difference(inary.db.installdb.InstallDB().list_installed())
         
         if unavailable_fw_packages:
             ctx.ui.info(inary.util.colorize("The following firmwares are not installed:", "yellow"))
diff --git a/inary/analyzer/forensic.py b/inary/analyzer/forensic.py
index 0e22aaf9..5b8ad5a9 100644
--- a/inary/analyzer/forensic.py
+++ b/inary/analyzer/forensic.py
@@ -78,10 +78,10 @@ def find_corrupted(rootdir, last_changed):
             filepath = '/' + filepath
             if not filepath.startswith(rootdir):
                 continue
-            sys.stdout.write("MISSING %s %s\n" % (package, filepath))
+            sys.stdout.write("MISSING {0} {1}\n".format(package, filepath))
             sys.stdout.flush()
 
-def forensics(rootdir='/',logfile=logfile):
+def forensics(rootdir='/',logfile='logfile'):
     if not rootdir.endswith('/'):
         rootdir += '/'
 
diff --git a/inary/analyzer/magic.py b/inary/analyzer/magic.py
new file mode 100644
index 00000000..e3ae685d
--- /dev/null
+++ b/inary/analyzer/magic.py
@@ -0,0 +1,122 @@
+
+
+import sys
+import glob
+import os
+import threading
+
+import ctypes
+from ctypes import c_char_p, c_int, c_size_t, c_void_p
+import ctypes.util
+
+libmagic = None
+dll = ctypes.util.find_library('magic') or ctypes.util.find_library('magic1') or ctypes.util.find_library('cygmagic-1')
+
+if dll:
+    libmagic = ctypes.CDLL(dll)
+
+if not libmagic or not libmagic._name:
+    raise ImportError('failed to find libmagic.  Check your installation')
+
+#Magic Flags from libmagic.so
+
+MAGIC_CONTINUE = 0x000020 
+MAGIC_COMPRESS = 0x000004
+MAGIC_NONE = 0x000000 
+MAGIC_MIME = 0x000010
+MAGIC_MIME_ENCODING = 0x000400 
+
+_instances = {}
+
+# Magic function
+magic_t = ctypes.c_void_p
+
+#Error Checking Function
+def errorcheck(result, func, args):
+    if result is None:
+        err = magic_error(args[0])
+        raise Exception(err)
+    elif result is -1:
+        err = magic_error(args[0])
+        raise Exception(err)
+    else:
+        return result
+
+
+magic_file = libmagic.magic_file
+magic_file.restype = c_char_p
+magic_file.argtypes = [magic_t, c_char_p]
+magic_file.errcheck = errorcheck
+
+magic_open = libmagic.magic_open
+magic_open.restype = magic_t
+magic_open.argtypes = [c_int]
+
+magic_close = libmagic.magic_close
+magic_close.restype = None
+magic_close.argtypes = [magic_t]
+
+magic_buffer = libmagic.magic_buffer
+magic_buffer.restype = c_char_p
+magic_buffer.argtypes = [magic_t, c_void_p, c_size_t]
+magic_buffer.errcheck = errorcheck
+
+magic_load = libmagic.magic_load
+magic_load.restype = c_int
+magic_load.argtypes = [magic_t, c_char_p]
+magic_load.errcheck = errorcheck
+
+#Standart Functions
+def _get_wrapper(mime):
+    i = _instances.get(mime)
+    if i is None:
+        i = _instances[mime] = Magic(mime=mime)
+    return i
+
+def file_type(data, mime=False):
+    m = _get_wrapper(mime)
+    return m.get_file_type(data)
+
+# Magic Class
+class Magic:
+
+    def __init__(self, mime=False, magic_file=None, mime_encoding=False,
+                 keep_going=False, uncompress=False):
+
+        self.flags = MAGIC_NONE
+        if mime:
+            self.flags |= MAGIC_MIME
+        if mime_encoding:
+            self.flags |= MAGIC_MIME_ENCODING
+        if keep_going:
+            self.flags |= MAGIC_CONTINUE
+
+        if uncompress:
+            self.flags |= MAGIC_COMPRESS
+
+        self.cookie = magic_open(self.flags)
+        self.lock = threading.Lock()
+
+        magic_load(self.cookie, magic_file)
+
+    def get_file_type(self, data):
+        # If given argument is a file load with magic_file 
+        # If given argument is a buffer load with magic_buffer
+        try:
+            if os.path.isfile(data): 
+                open(data)
+                with self.lock:
+                    return magic_file(self.cookie, data)
+            else: 
+                with self.lock:
+                    if type(data) == str and str != bytes:
+                        buf = data.encode('utf-8', errors='replace')
+                    return magic_buffer(self.cookie, data, len(data))
+        except Exception as err:
+            raise(_("Can Not load file or buffer {}").format(err))
+
+    def __del__(self):
+        if self.cookie and magic_close:
+            magic_close(self.cookie)
+            self.cookie = None
+
diff --git a/inary/analyzer/pkgconfig.py b/inary/analyzer/pkgconfig.py
index 846af161..7c7fe390 100644
--- a/inary/analyzer/pkgconfig.py
+++ b/inary/analyzer/pkgconfig.py
@@ -15,7 +15,6 @@ import os
 import re
 import sys
 import glob
-import magic
 import shutil
 import fnmatch
 import tempfile
@@ -25,6 +24,8 @@ import subprocess
 
 #Inary functions
 import inary
+import inary.db
+import inary.analyzer.magic
 import inary.context as ctx
 
 #Gettext
@@ -32,11 +33,6 @@ import gettext
 __trans = gettext.translation('inary', fallback=True)
 _ = __trans.gettext
 
-INSTALLDB = inary.db.installdb.InstallDB()
-COMPONENTDB = inary.db.componentdb.ComponentDB()
-CONSTANTS = inary.constants.Constants()
-REPODB = inary.db.repodb.RepoDB()
-FILESDB = inary.db.filesdb.FilesDB()
 
 class Error(inary.Error):
     pass
@@ -44,6 +40,10 @@ class Error(inary.Error):
 class LDD:
     def __init__(self, packages, directory, component, installed_list=True, systembase=False, systemdevel=False):
 
+        self.installdb = inary.db.installdb.InstallDB()
+        self.componentdb = inary.db.componentdb.ComponentDB()
+        self.repodb = inary.db.repodb.RepoDB()
+        self.filesdb = inary.db.filesdb.FilesDB()
         self.systembase = systembase
         self.systemdevel = systemdevel
         self.packages = package
@@ -59,12 +59,12 @@ class LDD:
         # check for components, like system.base, tex.language, etc.
         if self.component:
             for repo in RepoDB.list_repos():
-                if COMPONENTDB.has_component(component):
-                    self.packages.extend(COMPONENTDB.get_packages(component, repo))
+                if self.componentdb.has_component(component):
+                    self.packages.extend(self.componentdb.get_packages(component, repo))
 
         # check for all packages installed on the machine
         if installedlist:
-            self.packages.extend(INSTALLDB.list_installed())
+            self.packages.extend(self.installdb.list_installed())
 
     def find_dependencies_on_pkgconfig(self):
         pkgconfig_list = []
@@ -100,7 +100,7 @@ class LDD:
                 pkgconfig_list.append((result_broken, result_unused, result_undefined, result_lists, result_runpath, package_name))
 
             # Check for a installed package in the system
-            elif package in INSTALLDB.list_installed():
+            elif package in self.installdb.list_installed():
                 if used_inary:
                     raise Error("You've checked for a inary file before\nPlease do not check for a installed package and inary file at the same time")
 
@@ -108,7 +108,7 @@ class LDD:
                     package_name = package
 
                     # Gather runtime dependencies directly from the database of installed packages
-                    package_deps = [dep.name() for dep in INSTALLDB.get_package(package).runtimeDependencies()]
+                    package_deps = [dep.name() for dep in self.installdb.get_package(package).runtimeDependencies()]
                     package_tempdir = False # There is no need of temporary directory, hence we look for files that are installed
 
                     # Same functions in the above part. You can read them
@@ -216,12 +216,12 @@ class LDD:
         # get system.base and system.devel packages
         systembase_packages = []
         systemdevel_packages= []
-        for repo in REPODB.list_repos():
-            for component in COMPONENTDB.list_components(repo):
+        for repo in self.repodb.list_repos():
+            for component in self.componentdb.list_components(repo):
                 if component == "system.base":
-                    systembase_packages.extend(COMPONENTDB.get_packages('system.base', repo))
+                    systembase_packages.extend(self.componentdb.get_packages('system.base', repo))
                 if component == "system.devel":
-                    systemdevel_packages.extend(COMPONENTDB.get_packages('system.devel', repo))
+                    systemdevel_packages.extend(self.componentdb.get_packages('system.devel', repo))
 
         # look for packages that are system.base but are written as dependency
         # mark them with "*"
@@ -293,13 +293,13 @@ class LDD:
             package_pc_files = glob.glob("{}/usr/*/pkgconfig/*.pc".format(package_dir))
         else:
             package_files = set(["/{}".format(file_name.path) \
-                for file_name in INSTALLDB.get_files(package_name).list])
+                for file_name in self.installdb.get_files(package_name).list])
             package_pc_files = set([os.path.realpath("/{}".format(file_name.path)) \
-                    for file_name in INSTALLDB.get_files(package_name).list \
+                    for file_name in self.installdb.get_files(package_name).list \
                     if fnmatch.fnmatch(file_name.path, "*/pkgconfig/*.pc")])
 
         for package_file in package_files:
-            package_file_info = magic.from_file(package_file) #Return file type
+            package_file_info = inary.analyzer.magic.file_type(package_file) #Return file type
             if "LSB shared object" in package_file_info:
                 package_elf_files.append(os.path.realpath(package_file))
             elif "LSB executable" in package_file_info:
diff --git a/inary/api.py b/inary/api.py
index 0f9c884b..839af89c 100644
--- a/inary/api.py
+++ b/inary/api.py
@@ -16,16 +16,25 @@ __trans = gettext.translation('inary', fallback=True)
 _ = __trans.gettext
 
 import inary
+
+#Analyzers
+import inary.analyzer.ctypes_analyzer
+import inary.analyzer.forensic
+import inary.analyzer.pkgconfig
+
 import inary.atomicoperations
 import inary.blacklist
 import inary.config
 import inary.context as ctx
+
+#DataFile Libraries
 import inary.data
 import inary.data.index
 import inary.data.metadata
 import inary.data.pgraph
+
+#DataBase Libraries
 import inary.db.componentdb
-import inary.db.dbhelper
 import inary.db.packagedb
 import inary.db.repodb
 import inary.db.filesdb
@@ -34,8 +43,11 @@ import inary.db.historydb
 import inary.db.sourcedb
 import inary.db.componentdb
 import inary.db.groupdb
+
 import inary.errors
 import inary.file
+
+#Operation Libraries
 import inary.operations.build
 import inary.operations.check
 import inary.operations.emerge
@@ -46,6 +58,7 @@ import inary.operations.helper
 import inary.operations.remove
 import inary.operations.search
 import inary.operations.upgrade
+
 import inary.uri
 import inary.util
 
@@ -128,20 +141,22 @@ def set_options(options):
     ctx.config.set_options(options)
 
 # The following are INARY operations which constitute the INARY API
-from inary.operations.operations import *
+
+#It looking soo bad
+from inary.atomicoperations import *
 
 #Within functions
 from inary.analyzer.conflict import calculate_conflicts
-#from inary.analyzer.firmwares import get_firmware_package
+from inary.analyzer.firmwares import get_firmware_package
 from inary.data.index import index
 from inary.data.pgraph import package_graph
 from inary.fetcher import fetch
-from inary.db.dbhelper import *
 from inary.operations.build import build, build_until
 from inary.operations.helper import calculate_download_sizes, get_package_requirements
 from inary.operations.history import get_takeback_plan
 from inary.operations.info import info
 from inary.operations.install import get_install_order
+from inary.operations.op_wrappers import *
 from inary.operations.remove import get_remove_order
 from inary.operations.upgrade import get_upgrade_order, get_base_upgrade_order
 from inary.operations.search import *
diff --git a/inary/archive.py b/inary/archive.py
index 04387725..c9a63dd0 100644
--- a/inary/archive.py
+++ b/inary/archive.py
@@ -304,6 +304,7 @@ class ArchiveTar(ArchiveBase):
         except OSError:
             pass
 
+        ctx.ui.debug(_("* Target DIR: {}").format(target_dir))
         os.chdir(target_dir)
 
         for tarinfo in self.tar:
@@ -455,8 +456,10 @@ class ArchiveTar(ArchiveBase):
 
 
                 if not os.path.islink(tarinfo.name):
+                    ctx.ui.debug(_("* Chowning {0} ({1}:{2})").format(tarinfo.name, uid, gid))
                     os.chown(tarinfo.name, uid, gid)
                 else:
+                    ctx.ui.debug(_("* LChowning {0} ({1}:{2})").format(tarinfo.name, uid, gid))
                     os.lchown(tarinfo.name, uid, gid)
 
             if callback:
diff --git a/inary/atomicoperations.py b/inary/atomicoperations.py
index dd0c5d3e..bee55899 100644
--- a/inary/atomicoperations.py
+++ b/inary/atomicoperations.py
@@ -21,10 +21,10 @@ import zipfile
 
 import inary
 import inary.context as ctx
-import inary.data.specfile
-import inary.data.metadata
+import inary.data
+import inary.errors
 import inary.db
-import inary.operations.delta
+import inary.operations
 import inary.uri
 import inary.ui
 import inary.util as util
@@ -212,7 +212,7 @@ class Install(AtomicOperation):
         for f in self.files.list:
             pkg, existing_file = ctx.filesdb.get_file(f.path)
             if pkg:
-                dst = inary.util.join_path(ctx.config.dest_dir(), f.path)
+                dst = util.join_path(ctx.config.dest_dir(), f.path)
                 if pkg != self.pkginfo.name and not os.path.isdir(dst) and really_conflicts(pkg):
                     file_conflicts.append( (pkg, existing_file) )
         if file_conflicts:
@@ -612,7 +612,7 @@ class Remove(AtomicOperation):
         if fileinfo.permanent and not remove_permanent:
             return
 
-        fpath = inary.util.join_path(ctx.config.dest_dir(), fileinfo.path)
+        fpath = util.join_path(ctx.config.dest_dir(), fileinfo.path)
 
         historydb = inary.db.historydb.HistoryDB()
         # we should check if the file belongs to another
@@ -701,3 +701,387 @@ def build(package):
     # wrapper for build op
     import inary.operations.build
     return inary.operations.build.build(package)
+
+#API ORDERS
+def locked(func):
+    """
+    Decorator for synchronizing privileged functions
+    """
+    def wrapper(*__args,**__kw):
+        try:
+            lock = open(util.join_path(ctx.config.lock_dir(), 'inary'), 'w')
+        except IOError:
+            raise inary.errors.PrivilegeError(_("You have to be root for this operation."))
+
+        try:
+            fcntl.flock(lock, fcntl.LOCK_EX | fcntl.LOCK_NB)
+            ctx.locked = True
+        except IOError:
+            if not ctx.locked:
+                raise inary.errors.AnotherInstanceError(_("Another instance of Inary is running. Only one instance is allowed."))
+
+        try:
+            inary.db.invalidate_caches()
+            ret = func(*__args,**__kw)
+            inary.db.update_caches()
+            return ret
+        finally:
+            ctx.locked = False
+            lock.close()
+    return wrapper
+
+
+@locked
+def upgrade(packages=[], repo=None):
+    """
+    Upgrades the given packages, if no package given upgrades all the packages
+    @param packages: list of package names -> list_of_strings
+    @param repo: name of the repository that only the packages from that repo going to be upgraded
+    """
+    inary.db.historydb.HistoryDB().create_history("upgrade")
+    return inary.operations.upgrade.upgrade(packages, repo)
+
+@locked
+def remove(packages, ignore_dependency=False, ignore_safety=False):
+    """
+    Removes the given packages from the system
+    @param packages: list of package names -> list_of_strings
+    @param ignore_dependency: removes packages without looking into theirs reverse deps if True
+    @param ignore_safety: system.base packages can also be removed if True
+    """
+    inary.db.historydb.HistoryDB().create_history("remove")
+    return inary.operations.remove.remove(packages, ignore_dependency, ignore_safety)
+
+@locked
+def install(packages, reinstall=False, ignore_file_conflicts=False, ignore_package_conflicts=False):
+    """
+    Returns True if no errors occured during the operation
+    @param packages: list of package names -> list_of_strings
+    @param reinstall: reinstalls already installed packages else ignores
+    @param ignore_file_conflicts: Ignores file conflicts during the installation and continues to install
+    packages.
+    @param ignore_package_conflicts: Ignores package conflicts during the installation and continues to
+    install packages.
+    """
+
+    inary.db.historydb.HistoryDB().create_history("install")
+
+    if not ctx.get_option('ignore_file_conflicts'):
+        ctx.set_option('ignore_file_conflicts', ignore_file_conflicts)
+
+    if not ctx.get_option('ignore_package_conflicts'):
+        ctx.set_option('ignore_package_conflicts', ignore_package_conflicts)
+
+    # Install inary package files or inary packages from a repository
+    if packages and packages[0].endswith(ctx.const.package_suffix):
+        return inary.operations.install.install_pkg_files(packages, reinstall)
+    else:
+        return inary.operations.install.install_pkg_names(packages, reinstall)
+
+@locked
+def takeback(operation):
+    """
+    Takes back the system to a previous state. Uses inary history to find out which packages were
+    installed at the time _after_ the given operation that the system is requested to be taken back.
+    @param operation: number of the operation that the system will be taken back -> integer
+    """
+
+    historydb = inary.db.historydb.HistoryDB()
+    historydb.create_history("takeback")
+
+    inary.operations.history.takeback(operation)
+
+
+@locked
+def set_repo_activity(name, active):
+    """
+    Changes the activity status of a  repository. Inactive repositories will have no effect on
+    upgrades and installs.
+    @param name: name of the repository
+    @param active: the new repository status
+    """
+    repodb = inary.db.repodb.RepoDB()
+    if active:
+        repodb.activate_repo(name)
+    else:
+        repodb.deactivate_repo(name)
+    inary.db.regenerate_caches()
+
+@locked
+def emerge(packages):
+    """
+    Builds and installs the given packages from source
+    @param packages: list of package names -> list_of_strings
+    """
+    inary.db.historydb.HistoryDB().create_history("emerge")
+    return inary.operations.emerge.emerge(packages)
+
+@locked
+def delete_cache():
+    """
+    Deletes cached packages, cached archives, build dirs, db caches
+    """
+    ctx.ui.info(_("Cleaning package cache {}...").format(ctx.config.cached_packages_dir()))
+    util.clean_dir(ctx.config.cached_packages_dir())
+    ctx.ui.info(_("Cleaning source archive cache {}...").format(ctx.config.archives_dir()))
+    util.clean_dir(ctx.config.archives_dir())
+    ctx.ui.info(_("Cleaning temporary directory {}...").format(ctx.config.tmp_dir()))
+    util.clean_dir(ctx.config.tmp_dir())
+    for cache in [x for x in os.listdir(ctx.config.cache_root_dir()) if x.endswith(".cache")]:
+        cache_file = util.join_path(ctx.config.cache_root_dir(), cache)
+        ctx.ui.info(_("Removing cache file {}...").format(cache_file))
+        os.unlink(cache_file)
+
+def check(package, config=False):
+    """
+    Returns a dictionary that contains a list of both corrupted and missing files
+    @param package: name of the package to be checked
+    @param config: _only_ check the config files of the package, default behaviour is to check all the files
+    of the package but the config files
+    """
+    return inary.operations.check.check_package(package, config)
+
+@locked
+def snapshot():
+    """
+    Takes snapshot of the system packages. The snapshot is only a record of which packages are currently
+    installed. The record is kept by inary history mechanism as it works automatically on install, remove
+    and upgrade operations.
+    """
+
+    installdb = inary.db.installdb.InstallDB()
+    historydb = inary.db.historydb.HistoryDB()
+    historydb.create_history("snapshot")
+
+    li = installdb.list_installed()
+    progress = ctx.ui.Progress(len(li))
+
+    processed = 0
+    for name in installdb.list_installed():
+        package = installdb.get_package(name)
+        historydb.add_package(pkgBefore=package, operation="snapshot")
+        # Save changed config files of the package in snapshot
+        for f in installdb.get_files(name).list:
+            if f.type == "config" and util.config_changed(f):
+                fpath = util.join_path(ctx.config.dest_dir(), f.path)
+                historydb.save_config(name, fpath)
+
+        processed += 1
+        ctx.ui.display_progress(operation = "snapshot",
+                                percent = progress.update(processed),
+                                info = _("Taking snapshot of the system"))
+
+    historydb.update_history()
+
+@locked
+def configure_pending(packages=None):
+    # Import SCOM
+    import inary.scomiface
+
+    # start with pending packages
+    # configure them in reverse topological order of dependency
+    installdb = inary.db.installdb.InstallDB()
+    if not packages:
+        packages = installdb.list_pending()
+    else:
+        packages = set(packages).intersection(installdb.list_pending())
+
+    order = generate_pending_order(packages)
+    try:
+        for x in order:
+            if installdb.has_package(x):
+                pkginfo = installdb.get_package(x)
+                pkg_path = installdb.package_path(x)
+                m = inary.data.metadata.MetaData()
+                metadata_path = util.join_path(pkg_path, ctx.const.metadata_xml)
+                m.read(metadata_path)
+                # FIXME: we need a full package info here!
+                pkginfo.name = x
+                ctx.ui.notify(inary.ui.configuring, package = pkginfo, files = None)
+                inary.scomiface.post_install(
+                    pkginfo.name,
+                    m.package.providesScom,
+                    util.join_path(pkg_path, ctx.const.scom_dir),
+                    util.join_path(pkg_path, ctx.const.metadata_xml),
+                    util.join_path(pkg_path, ctx.const.files_xml),
+                    None,
+                    None,
+                    m.package.version,
+                    m.package.release
+                )
+                ctx.ui.notify(inary.ui.configured, package = pkginfo, files = None)
+            installdb.clear_pending(x)
+    except ImportError:
+        raise inary.Error(_("scom package is not fully installed"))
+
+
+@locked
+def add_repo(name, indexuri, at = None):
+    import re
+    if not re.match("^[0-9{}\-\\_\\.\s]*$".format(str(util.letters())), name):
+        raise inary.Error(_('Not a valid repo name.'))
+    repodb = inary.db.repodb.RepoDB()
+    if repodb.has_repo(name):
+        raise inary.Error(_('Repo {} already present.').format(name))
+    elif repodb.has_repo_url(indexuri, only_active = False):
+        repo = repodb.get_repo_by_url(indexuri)
+        raise inary.Error(_('Repo already present with name {}.').format(repo))
+    else:
+        repo = inary.db.repodb.Repo(inary.uri.URI(indexuri))
+        repodb.add_repo(name, repo, at = at)
+        inary.db.flush_caches()
+        ctx.ui.info(_('Repo {} added to system.').format(name))
+
+@locked
+def remove_repo(name):
+    repodb = inary.db.repodb.RepoDB()
+    if repodb.has_repo(name):
+        repodb.remove_repo(name)
+        inary.db.flush_caches()
+        ctx.ui.info(_('Repo {} removed from system.').format(name))
+    else:
+        raise inary.Error(_('Repository {} does not exist. Cannot remove.').format(name))
+
+@locked
+def update_repos(repos, force=False):
+    inary.db.historydb.HistoryDB().create_history("repoupdate")
+    updated = False
+    try:
+        for repo in repos:
+            updated |= __update_repo(repo, force)
+    finally:
+        if updated:
+            inary.db.regenerate_caches()
+
+@locked
+def update_repo(repo, force=False):
+    inary.db.historydb.HistoryDB().create_history("repoupdate")
+    updated = __update_repo(repo, force)
+    if updated:
+        inary.db.regenerate_caches()
+
+def __update_repo(repo, force=False):
+    ctx.ui.action(_('Updating repository: {}').format(repo))
+    ctx.ui.notify(inary.ui.updatingrepo, name = repo)
+    repodb = inary.db.repodb.RepoDB()
+    index = inary.data.index.Index()
+    if repodb.has_repo(repo):
+        repouri = repodb.get_repo(repo).indexuri.get_uri()
+        try:
+            index.read_uri_of_repo(repouri, repo)
+        except inary.file.AlreadyHaveException as e:
+            ctx.ui.info(_('{} repository information is up-to-date.').format(repo))
+            if force:
+                ctx.ui.info(_('Updating database at any rate as requested'))
+                index.read_uri_of_repo(repouri, repo, force = force)
+            else:
+                return False
+
+        inary.db.historydb.HistoryDB().update_repo(repo, repouri, "update")
+        repodb.check_distribution(repo)
+
+        try:
+            index.check_signature(repouri, repo)
+        except inary.file.NoSignatureFound as e:
+            ctx.ui.warning(e)
+
+        ctx.ui.info(_('Package database updated.'))
+    else:
+        raise inary.Error(_('No repository named {} found.').format(repo))
+
+    return True
+
+# FIXME: rebuild_db is only here for filesdb and it really is ugly. we should not need any rebuild.
+@locked
+def rebuild_db():
+
+    # save parameters and shutdown inary
+    options = ctx.config.options
+    ui = ctx.ui
+    scom = ctx.scom
+    inary._cleanup()
+
+    ctx.filesdb.close()
+    ctx.filesdb.destroy()
+    ctx.filesdb = inary.db.filesdb.FilesDB()
+
+    # reinitialize everything
+    ctx.ui = ui
+    ctx.config.set_options(options)
+    ctx.scom = scom
+
+@locked
+def clearCache(all=False):
+
+    import glob
+
+    def getPackageLists(pkgList):
+        latest = {}
+        for f in pkgList:
+            try:
+                name, full_version = util.parse_package_name(f)
+                version, release, build = util.split_version(full_version)
+
+                release = int(release)
+                if name in latest:
+                    lversion, lrelease = latest[name]
+                    if lrelease > release:
+                        continue
+
+                latest[name] = full_version, release
+
+            except:
+                pass
+
+        latestVersions = []
+        for pkg in latest:
+            latestVersions.append("{0}-{1}".format(pkg, latest[pkg][0]))
+
+        oldVersions = list(set(pkgList) - set(latestVersions))
+        return oldVersions, latestVersions
+
+    def getRemoveOrder(cacheDir, pkgList):
+        sizes = {}
+        for pkg in pkgList:
+            sizes[pkg] = os.stat(os.path.join(cacheDir, pkg) + ctx.const.package_suffix).st_size
+
+        # sort dictionary by value from PEP-265
+        from operator import itemgetter
+        return sorted(iter(sizes.items()), key=itemgetter(1), reverse=False)
+
+    def removeOrderByLimit(cacheDir, order, limit):
+        totalSize = 0
+        for pkg, size in order:
+            totalSize += size
+            if totalSize >= limit:
+                try:
+                    os.remove(os.path.join(cacheDir, pkg) + ctx.const.package_suffix)
+                except exceptions.OSError:
+                    pass
+
+    def removeAll(cacheDir):
+        cached = glob.glob("{}/*.inary".format(cacheDir)) + glob.glob("{}/*.part".format(cacheDir))
+        for pkg in cached:
+            try:
+                os.remove(pkg)
+            except exceptions.OSError:
+                pass
+
+    cacheDir = ctx.config.cached_packages_dir()
+
+    pkgList = [os.path.basename(x).split(ctx.const.package_suffix)[0] for x in glob.glob("{}/*.inary".format(cacheDir))]
+    if not all:
+        # Cache limits from inary.conf
+        config = inary.configfile.ConfigurationFile("/etc/inary/inary.conf")
+        cacheLimit = int(config.get("general", "package_cache_limit")) * 1024 * 1024 # is this safe?
+        if not cacheLimit:
+            return
+
+        old, latest = getPackageLists(pkgList)
+        order = getRemoveOrder(cacheDir, latest) + getRemoveOrder(cacheDir, old)
+        removeOrderByLimit(cacheDir, order, cacheLimit)
+    else:
+        removeAll(cacheDir)
+
+def reorder_base_packages(*args, **kw):
+    return inary.operations.helper.reorder_base_packages(*args, **kw)
diff --git a/inary/cli/__init__.py b/inary/cli/__init__.py
index 7b5a22cc..a60b3959 100644
--- a/inary/cli/__init__.py
+++ b/inary/cli/__init__.py
@@ -163,7 +163,7 @@ class CLI(inary.ui.UI):
 
         while True:
             tty.tcflush(sys.stdin.fileno(), 0)
-            prompt = msg + inary.util.colorize(_(' (yes/no)'), 'red')
+            prompt = msg + inary.util.colorize(_(' (yes'), 'green') + '/' + inary.util.colorize(_('no)'), 'red')
             s = input(prompt)
 
             if yes_expr.search(s):
diff --git a/inary/cli/command.py b/inary/cli/command.py
index e99fd240..c2069b14 100644
--- a/inary/cli/command.py
+++ b/inary/cli/command.py
@@ -167,7 +167,7 @@ class Command(object):
             ('sf' in self.get_name() and not os.access(os.path.join(ctx.config.info_dir(), ctx.const.files_ldb), os.W_OK))):
             raise inary.cli.Error(_("You have to be root for this operation."))
 
-        inary.api.set_scom(self.scom and not ctx.get_option('ignore_comar'))
+        inary.api.set_scom(self.scom and not ctx.get_option('ignore_scom'))
         inary.api.set_userinterface(ui)
         inary.api.set_options(self.options)
 
diff --git a/inary/db/filesdb.py b/inary/db/filesdb.py
index ab20ef46..307619f3 100644
--- a/inary/db/filesdb.py
+++ b/inary/db/filesdb.py
@@ -46,10 +46,8 @@ class FilesDB(lazydb.LazyDB):
         ctx.ui.info(inary.util.colorize(_('Creating files database...'), 'blue'))
         installdb = inary.db.installdb.InstallDB()
         for pkg in installdb.list_installed():
-            ctx.ui.info(inary.util.colorize(_('  |___* Adding \'{}\' to db... '), 'purple').format(pkg), noln=True)
             files = installdb.get_files(pkg)
             self.add_files(pkg, files)
-            ctx.ui.info(inary.util.colorize(_('OK.'), 'backgroundmagenta'))
         ctx.ui.info(inary.util.colorize(_('Added files database...'), 'blue'))
 
     def get_file(self, path):
@@ -71,12 +69,12 @@ class FilesDB(lazydb.LazyDB):
         return found
 
     def add_files(self, pkg, files):
-
         self.__check_filesdb()
-        ctx.ui.info(inary.util.colorize(_('* Adding \'{}\' to db... '), 'purple').format(pkg), noln=True)
+        ctx.ui.info(inary.util.colorize(_('  |___* Adding \'{}\' to db... '), 'purple').format(pkg), noln=True)
         for f in files.list:
             key=hashlib.md5(f.path.encode('utf-8')).hexdigest()
             self.filesdb[key] = pkg
+        ctx.ui.info(inary.util.colorize(_('OK.'), 'backgroundmagenta'))
 
     def remove_files(self, files):
         for f in files:
@@ -94,7 +92,6 @@ class FilesDB(lazydb.LazyDB):
             self.filesdb.close()
 
     def __check_filesdb(self):
-        ctx.ui.info(_("Checking filesdb..."))
         if isinstance(self.filesdb, shelve.DbfilenameShelf):
             return
 
diff --git a/inary/operations/build.py b/inary/operations/build.py
index 5c5a8bb7..81a6d9f8 100644
--- a/inary/operations/build.py
+++ b/inary/operations/build.py
@@ -1001,12 +1001,12 @@ class Builder:
     def file_actions(self):
         install_dir = self.pkg_install_dir()
 
-        import magic
+        import inary.analyzer.magic as magic
 
         for root, dirs, files in os.walk(install_dir):
             for fn in files:
                 filepath = util.join_path(root, fn)
-                fileinfo = magic.from_file(filepath)
+                fileinfo = magic.file_type(filepath)
                 strip_debug_action(filepath, fileinfo, install_dir, self.actionGlobals)
                 exclude_special_files(filepath, fileinfo, self.actionGlobals)
 
diff --git a/inary/operations/info.py b/inary/operations/info.py
index 734bf67f..9f5011c3 100644
--- a/inary/operations/info.py
+++ b/inary/operations/info.py
@@ -14,6 +14,10 @@ import inary
 import inary.db
 import inary.data
 
+import gettext
+__trans = gettext.translation('inary', fallback=True)
+_ = __trans.gettext
+
 def info(package, installed = False):
     if package.endswith(ctx.const.package_suffix):
         return info_file(package)
diff --git a/inary/db/dbhelper.py b/inary/operations/op_wrappers.py
similarity index 100%
rename from inary/db/dbhelper.py
rename to inary/operations/op_wrappers.py
diff --git a/inary/operations/operations.py b/inary/operations/operations.py
deleted file mode 100644
index 0fd8cbdc..00000000
--- a/inary/operations/operations.py
+++ /dev/null
@@ -1,410 +0,0 @@
-# -*- coding: utf-8 -*-
-#
-# Copyright (C) 2018, Suleyman POYRAZ (Zaryob)
-#
-# This program is free software; you can redistribute it and/or modify it under
-# the terms of the GNU General Public License as published by the Free
-# Software Foundation; either version 2 of the License, or (at your option)
-# any later version.
-#
-# Please read the COPYING file.
-#
-
-import os
-import fcntl
-
-import inary
-import inary.atomicoperations
-import inary.context as ctx
-import inary.db
-import inary.data
-import inary.errors
-import inary.fetcher
-import inary.file
-import inary.operations
-import inary.ui
-import inary.util
-
-#API ORDERS
-def locked(func):
-    """
-    Decorator for synchronizing privileged functions
-    """
-    def wrapper(*__args,**__kw):
-        try:
-            lock = open(inary.util.join_path(ctx.config.lock_dir(), 'inary'), 'w')
-        except IOError:
-            raise inary.errors.PrivilegeError(_("You have to be root for this operation."))
-
-        try:
-            fcntl.flock(lock, fcntl.LOCK_EX | fcntl.LOCK_NB)
-            ctx.locked = True
-        except IOError:
-            if not ctx.locked:
-                raise inary.errors.AnotherInstanceError(_("Another instance of Inary is running. Only one instance is allowed."))
-
-        try:
-            inary.db.invalidate_caches()
-            ret = func(*__args,**__kw)
-            inary.db.update_caches()
-            return ret
-        finally:
-            ctx.locked = False
-            lock.close()
-    return wrapper
-
-
-@locked
-def upgrade(packages=[], repo=None):
-    """
-    Upgrades the given packages, if no package given upgrades all the packages
-    @param packages: list of package names -> list_of_strings
-    @param repo: name of the repository that only the packages from that repo going to be upgraded
-    """
-    inary.db.historydb.HistoryDB().create_history("upgrade")
-    return inary.operations.upgrade.upgrade(packages, repo)
-
-@locked
-def remove(packages, ignore_dependency=False, ignore_safety=False):
-    """
-    Removes the given packages from the system
-    @param packages: list of package names -> list_of_strings
-    @param ignore_dependency: removes packages without looking into theirs reverse deps if True
-    @param ignore_safety: system.base packages can also be removed if True
-    """
-    inary.db.historydb.HistoryDB().create_history("remove")
-    return inary.operations.remove.remove(packages, ignore_dependency, ignore_safety)
-
-@locked
-def install(packages, reinstall=False, ignore_file_conflicts=False, ignore_package_conflicts=False):
-    """
-    Returns True if no errors occured during the operation
-    @param packages: list of package names -> list_of_strings
-    @param reinstall: reinstalls already installed packages else ignores
-    @param ignore_file_conflicts: Ignores file conflicts during the installation and continues to install
-    packages.
-    @param ignore_package_conflicts: Ignores package conflicts during the installation and continues to
-    install packages.
-    """
-
-    inary.db.historydb.HistoryDB().create_history("install")
-
-    if not ctx.get_option('ignore_file_conflicts'):
-        ctx.set_option('ignore_file_conflicts', ignore_file_conflicts)
-
-    if not ctx.get_option('ignore_package_conflicts'):
-        ctx.set_option('ignore_package_conflicts', ignore_package_conflicts)
-
-    # Install inary package files or inary packages from a repository
-    if packages and packages[0].endswith(ctx.const.package_suffix):
-        return inary.operations.install.install_pkg_files(packages, reinstall)
-    else:
-        return inary.operations.install.install_pkg_names(packages, reinstall)
-
-@locked
-def takeback(operation):
-    """
-    Takes back the system to a previous state. Uses inary history to find out which packages were
-    installed at the time _after_ the given operation that the system is requested to be taken back.
-    @param operation: number of the operation that the system will be taken back -> integer
-    """
-
-    historydb = inary.db.historydb.HistoryDB()
-    historydb.create_history("takeback")
-
-    inary.operations.history.takeback(operation)
-
-
-@locked
-def set_repo_activity(name, active):
-    """
-    Changes the activity status of a  repository. Inactive repositories will have no effect on
-    upgrades and installs.
-    @param name: name of the repository
-    @param active: the new repository status
-    """
-    repodb = inary.db.repodb.RepoDB()
-    if active:
-        repodb.activate_repo(name)
-    else:
-        repodb.deactivate_repo(name)
-    inary.db.regenerate_caches()
-
-@locked
-def emerge(packages):
-    """
-    Builds and installs the given packages from source
-    @param packages: list of package names -> list_of_strings
-    """
-    inary.db.historydb.HistoryDB().create_history("emerge")
-    return inary.operations.emerge.emerge(packages)
-
-@locked
-def delete_cache():
-    """
-    Deletes cached packages, cached archives, build dirs, db caches
-    """
-    ctx.ui.info(_("Cleaning package cache {}...").format(ctx.config.cached_packages_dir()))
-    inary.util.clean_dir(ctx.config.cached_packages_dir())
-    ctx.ui.info(_("Cleaning source archive cache {}...").format(ctx.config.archives_dir()))
-    inary.util.clean_dir(ctx.config.archives_dir())
-    ctx.ui.info(_("Cleaning temporary directory {}...").format(ctx.config.tmp_dir()))
-    inary.util.clean_dir(ctx.config.tmp_dir())
-    for cache in [x for x in os.listdir(ctx.config.cache_root_dir()) if x.endswith(".cache")]:
-        cache_file = inary.util.join_path(ctx.config.cache_root_dir(), cache)
-        ctx.ui.info(_("Removing cache file {}...").format(cache_file))
-        os.unlink(cache_file)
-
-def check(package, config=False):
-    """
-    Returns a dictionary that contains a list of both corrupted and missing files
-    @param package: name of the package to be checked
-    @param config: _only_ check the config files of the package, default behaviour is to check all the files
-    of the package but the config files
-    """
-    return inary.operations.check.check_package(package, config)
-
-@locked
-def snapshot():
-    """
-    Takes snapshot of the system packages. The snapshot is only a record of which packages are currently
-    installed. The record is kept by inary history mechanism as it works automatically on install, remove
-    and upgrade operations.
-    """
-
-    installdb = inary.db.installdb.InstallDB()
-    historydb = inary.db.historydb.HistoryDB()
-    historydb.create_history("snapshot")
-
-    li = installdb.list_installed()
-    progress = ctx.ui.Progress(len(li))
-
-    processed = 0
-    for name in installdb.list_installed():
-        package = installdb.get_package(name)
-        historydb.add_package(pkgBefore=package, operation="snapshot")
-        # Save changed config files of the package in snapshot
-        for f in installdb.get_files(name).list:
-            if f.type == "config" and inary.util.config_changed(f):
-                fpath = inary.util.join_path(ctx.config.dest_dir(), f.path)
-                historydb.save_config(name, fpath)
-
-        processed += 1
-        ctx.ui.display_progress(operation = "snapshot",
-                                percent = progress.update(processed),
-                                info = _("Taking snapshot of the system"))
-
-    historydb.update_history()
-
-@locked
-def configure_pending(packages=None):
-    # Import SCOM
-    import inary.scomiface
-
-    # start with pending packages
-    # configure them in reverse topological order of dependency
-    installdb = inary.db.installdb.InstallDB()
-    if not packages:
-        packages = installdb.list_pending()
-    else:
-        packages = set(packages).intersection(installdb.list_pending())
-
-    order = generate_pending_order(packages)
-    try:
-        for x in order:
-            if installdb.has_package(x):
-                pkginfo = installdb.get_package(x)
-                pkg_path = installdb.package_path(x)
-                m = inary.data.metadata.MetaData()
-                metadata_path = inary.util.join_path(pkg_path, ctx.const.metadata_xml)
-                m.read(metadata_path)
-                # FIXME: we need a full package info here!
-                pkginfo.name = x
-                ctx.ui.notify(inary.ui.configuring, package = pkginfo, files = None)
-                inary.scomiface.post_install(
-                    pkginfo.name,
-                    m.package.providesScom,
-                    inary.util.join_path(pkg_path, ctx.const.scom_dir),
-                    inary.util.join_path(pkg_path, ctx.const.metadata_xml),
-                    inary.util.join_path(pkg_path, ctx.const.files_xml),
-                    None,
-                    None,
-                    m.package.version,
-                    m.package.release
-                )
-                ctx.ui.notify(inary.ui.configured, package = pkginfo, files = None)
-            installdb.clear_pending(x)
-    except ImportError:
-        raise inary.Error(_("scom package is not fully installed"))
-
-
-@locked
-def add_repo(name, indexuri, at = None):
-    import re
-    if not re.match("^[0-9{}\-\\_\\.\s]*$".format(str(inary.util.letters())), name):
-        raise inary.Error(_('Not a valid repo name.'))
-    repodb = inary.db.repodb.RepoDB()
-    if repodb.has_repo(name):
-        raise inary.Error(_('Repo {} already present.').format(name))
-    elif repodb.has_repo_url(indexuri, only_active = False):
-        repo = repodb.get_repo_by_url(indexuri)
-        raise inary.Error(_('Repo already present with name {}.').format(repo))
-    else:
-        repo = inary.db.repodb.Repo(inary.uri.URI(indexuri))
-        repodb.add_repo(name, repo, at = at)
-        inary.db.flush_caches()
-        ctx.ui.info(_('Repo {} added to system.').format(name))
-
-@locked
-def remove_repo(name):
-    repodb = inary.db.repodb.RepoDB()
-    if repodb.has_repo(name):
-        repodb.remove_repo(name)
-        inary.db.flush_caches()
-        ctx.ui.info(_('Repo {} removed from system.').format(name))
-    else:
-        raise inary.Error(_('Repository {} does not exist. Cannot remove.').format(name))
-
-@locked
-def update_repos(repos, force=False):
-    inary.db.historydb.HistoryDB().create_history("repoupdate")
-    updated = False
-    try:
-        for repo in repos:
-            updated |= __update_repo(repo, force)
-    finally:
-        if updated:
-            inary.db.regenerate_caches()
-
-@locked
-def update_repo(repo, force=False):
-    inary.db.historydb.HistoryDB().create_history("repoupdate")
-    updated = __update_repo(repo, force)
-    if updated:
-        inary.db.regenerate_caches()
-
-def __update_repo(repo, force=False):
-    ctx.ui.action(_('Updating repository: {}').format(repo))
-    ctx.ui.notify(inary.ui.updatingrepo, name = repo)
-    repodb = inary.db.repodb.RepoDB()
-    index = inary.data.index.Index()
-    if repodb.has_repo(repo):
-        repouri = repodb.get_repo(repo).indexuri.get_uri()
-        try:
-            index.read_uri_of_repo(repouri, repo)
-        except inary.file.AlreadyHaveException as e:
-            ctx.ui.info(_('{} repository information is up-to-date.').format(repo))
-            if force:
-                ctx.ui.info(_('Updating database at any rate as requested'))
-                index.read_uri_of_repo(repouri, repo, force = force)
-            else:
-                return False
-
-        inary.db.historydb.HistoryDB().update_repo(repo, repouri, "update")
-        repodb.check_distribution(repo)
-
-        try:
-            index.check_signature(repouri, repo)
-        except inary.file.NoSignatureFound as e:
-            ctx.ui.warning(e)
-
-        ctx.ui.info(_('Package database updated.'))
-    else:
-        raise inary.Error(_('No repository named {} found.').format(repo))
-
-    return True
-
-# FIXME: rebuild_db is only here for filesdb and it really is ugly. we should not need any rebuild.
-@locked
-def rebuild_db():
-
-    # save parameters and shutdown inary
-    options = ctx.config.options
-    ui = ctx.ui
-    scom = ctx.scom
-    inary._cleanup()
-
-    ctx.filesdb.close()
-    ctx.filesdb.destroy()
-    ctx.filesdb = inary.db.filesdb.FilesDB()
-
-    # reinitialize everything
-    ctx.ui = ui
-    ctx.config.set_options(options)
-    ctx.scom = scom
-
-@locked
-def clearCache(all=False):
-
-    import glob
-
-    def getPackageLists(pkgList):
-        latest = {}
-        for f in pkgList:
-            try:
-                name, full_version = inary.util.parse_package_name(f)
-                version, release, build = inary.util.split_version(full_version)
-
-                release = int(release)
-                if name in latest:
-                    lversion, lrelease = latest[name]
-                    if lrelease > release:
-                        continue
-
-                latest[name] = full_version, release
-
-            except:
-                pass
-
-        latestVersions = []
-        for pkg in latest:
-            latestVersions.append("{0}-{1}".format(pkg, latest[pkg][0]))
-
-        oldVersions = list(set(pkgList) - set(latestVersions))
-        return oldVersions, latestVersions
-
-    def getRemoveOrder(cacheDir, pkgList):
-        sizes = {}
-        for pkg in pkgList:
-            sizes[pkg] = os.stat(os.path.join(cacheDir, pkg) + ctx.const.package_suffix).st_size
-
-        # sort dictionary by value from PEP-265
-        from operator import itemgetter
-        return sorted(iter(sizes.items()), key=itemgetter(1), reverse=False)
-
-    def removeOrderByLimit(cacheDir, order, limit):
-        totalSize = 0
-        for pkg, size in order:
-            totalSize += size
-            if totalSize >= limit:
-                try:
-                    os.remove(os.path.join(cacheDir, pkg) + ctx.const.package_suffix)
-                except exceptions.OSError:
-                    pass
-
-    def removeAll(cacheDir):
-        cached = glob.glob("{}/*.inary".format(cacheDir)) + glob.glob("{}/*.part".format(cacheDir))
-        for pkg in cached:
-            try:
-                os.remove(pkg)
-            except exceptions.OSError:
-                pass
-
-    cacheDir = ctx.config.cached_packages_dir()
-
-    pkgList = [os.path.basename(x).split(ctx.const.package_suffix)[0] for x in glob.glob("{}/*.inary".format(cacheDir))]
-    if not all:
-        # Cache limits from inary.conf
-        config = inary.configfile.ConfigurationFile("/etc/inary/inary.conf")
-        cacheLimit = int(config.get("general", "package_cache_limit")) * 1024 * 1024 # is this safe?
-        if not cacheLimit:
-            return
-
-        old, latest = getPackageLists(pkgList)
-        order = getRemoveOrder(cacheDir, latest) + getRemoveOrder(cacheDir, old)
-        removeOrderByLimit(cacheDir, order, cacheLimit)
-    else:
-        removeAll(cacheDir)
-
-def reorder_base_packages(*args, **kw):
-    return inary.operations.helper.reorder_base_packages(*args, **kw)
diff --git a/inary/scomiface.py b/inary/scomiface.py
index 51b6c5c2..ae640e6e 100644
--- a/inary/scomiface.py
+++ b/inary/scomiface.py
@@ -27,6 +27,7 @@ class Error(inary.Error):
 try:
     import scom
     import dbus
+
 except ImportError:
     raise Error(_("scom-api package is not fully installed"))
 
